<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="/stylesheets/main.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" />
    <title>
        
            Map (no reduce) with Ripeline - Aaron Schlesinger
        
    </title>
</head>

<body>
	<div id="fb-root"></div>
	<script>(function(d, s, id) {
	  var js, fjs = d.getElementsByTagName(s)[0];
	  if (d.getElementById(id)) return;
	  js = d.createElement(s); js.id = id;
	  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=356721397759981";
	  fjs.parentNode.insertBefore(js, fjs);
	}(document, 'script', 'facebook-jssdk'));</script>
	
    <a href="http://github.com/arschles">
        <img style="position: absolute; top: 0; left: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub" />
    </a>
    
    <h1 class="header_text"><a href="/">Aaron Schlesinger</a></h1>
    
    
        <div class="page_title">Map (no reduce) with Ripeline</div>
    
    
    <div class="content">
        
<div id="post">
  <p>I went to MongoSF 2011 and attended a talk called "MongoDB's New Aggregation Features - A Sneak Peek" by Chris Westin. As of writing, I don't believe that slides are posted, but they will be soon.</p>

<p>In the talk, Chris said that they're working on pipeline-based aggregation for Mongo, as well as a rich set of pre-built operators that can be applied in any order in that pipeline. Step 1: define your data (a Mongo collection), step 2: write your pipeline, step 3: profit.</p>

<p>In functional terms, this Mongo pipeline is functionally equivalent to applying multiple mappers to each element in a collection (ruby's version for Arrays: <a href="http://www.ruby-doc.org/core/classes/Array.html#M000249">http://www.ruby-doc.org/core/classes/Array.html#M000249</a>), and streaming results from each mapper to the next. That model fits lots of problems too, and it's simpler to conceptualize. Sometimes you just don't need to reduce.</p>

<p>Turns out someone wrote a <a href="http://code.google.com/p/appengine-pipeline/">pipeline for appengine</a> which can be used to implement this very system outside of Mongo.</p>

<p>But I wanted to do it on totally open infrastructure so it can be used anywhere, so I started implementing the same idea and so far I have <a href="http://github.com/arschles/ripeline">ripeline (ruby + pipeline = ripeline)</a>. Ripeline uses redis for communication between the mappers (as well as stats collection), and ruby to write each mapper and coordinate everything.</p>

<p>The ideal is to be able to write mappers in ruby once and then tell the system the order in which to run them, and it takes care of the rest: monitoring, communication, streaming, failure detection, etc... On top of that, I'd love to build futures on top of the pipeline so that, for pipelines that will complete in a reasonable amount of time, you can start a pipeline and then hold a future for that pipeline's result.</p>

<p>Although MapReduce is a really rich &amp; proven computation model, you sometimes don't need the reduce step, and so you can go to a simpler solution. I'd like Ripeline to be that.</p>

</div>
<div class="fb-comments" data-href="http://arschles.github.com/2011/04/25/Map-no-reduce.html" data-width="500" data-num-posts="50"></div>

<div class="top_space"></div>
<div id="fb-root"></div>
<script src="http://connect.facebook.net/en_US/all.js#xfbml=1"></script>
    </div>
    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-25255506-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
</body>
</html>